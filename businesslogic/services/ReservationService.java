package businesslogic.services;

import businesslogic.entities.Reservation;
import businesslogic.entities.Customer;
import businesslogic.entities.Flight;
import businesslogic.entities.Seat;
import businesslogic.entities.Payment;
import businesslogic.entities.enums.ReservationStatus;
import datalayer.dao.ReservationDAO;
import datalayer.dao.SeatDAO;

import java.sql.SQLException;
import java.time.LocalDateTime;
import java.util.List;

/**
 * Service class for reservation-related business logic.
 * Handles creating, modifying, and canceling reservations.
 */
public class ReservationService {
    
    private ReservationDAO reservationDAO;
    private SeatDAO seatDAO;
    private FlightService flightService;
    
    public ReservationService(ReservationDAO reservationDAO,
                              SeatDAO seatDAO,
                              FlightService flightService) {
        this.reservationDAO = reservationDAO;
        this.seatDAO = seatDAO;
        this.flightService = flightService;
    }
    
    /**
     * Create a new reservation.
     * @param customer Customer making the reservation
     * @param flight Flight being reserved
     * @param selectedSeats List of seats to reserve
     * @return Created reservation or null if creation failed
     */
    public Reservation createReservation(Customer customer, Flight flight, 
                                        List<Seat> selectedSeats) throws SQLException {
        if (customer == null || flight == null || selectedSeats == null || selectedSeats.isEmpty()) {
            throw new IllegalArgumentException("Customer, flight, and seats are required");
        }
        
        // Validate seats are available
        for (Seat seat : selectedSeats) {
            Seat dbSeat = seatDAO.findById(seat.getSeatId());
            if (dbSeat == null || !dbSeat.isAvailable()) {
                throw new IllegalStateException("Seat " + seat.getSeatNumber() + " is not available");
            }
        }
        
        // Check flight has enough available seats
        if (flight.getAvailableSeats() < selectedSeats.size()) {
            throw new IllegalStateException("Not enough seats available on flight");
        }
        
        // Calculate total price
        double totalPrice = calculateTotalPrice(flight, selectedSeats);
        
        // Create reservation with PENDING status
        Reservation reservation = new Reservation(
            0, // ID will be generated by database
            LocalDateTime.now(),
            ReservationStatus.PENDING,
            totalPrice,
            customer,
            flight,
            null, // Payment will be added later
            selectedSeats
        );
        
        // Save reservation
        Reservation saved = reservationDAO.save(reservation);
        
        // Mark seats as unavailable
        for (Seat seat : selectedSeats) {
            seat.setAvailable(false);
            seatDAO.update(seat);
        }
        
        // Update flight available seats
        flightService.bookSeats(flight.getFlightNumber(), selectedSeats.size());
        
        return saved;
    }
    
    /**
     * Confirm a reservation (after payment is processed).
     * @param reservationId Reservation ID
     * @param payment Payment object
     * @return true if confirmation successful
     */
    public boolean confirmReservation(int reservationId, Payment payment) throws SQLException {
        Reservation reservation = reservationDAO.findById(reservationId);
        if (reservation == null) {
            return false;
        }
        
        if (reservation.getStatus() != ReservationStatus.PENDING) {
            throw new IllegalStateException("Only pending reservations can be confirmed");
        }
        
        reservation.setStatus(ReservationStatus.CONFIRMED);
        reservation.setPayment(payment);
        
        return reservationDAO.update(reservation);
    }
    
    /**
     * Cancel a reservation.
     * @param reservationId Reservation ID
     * @return true if cancellation successful
     */
    public boolean cancelReservation(int reservationId) throws SQLException {
        Reservation reservation = reservationDAO.findById(reservationId);
        if (reservation == null) {
            return false;
        }
        
        if (reservation.getStatus() == ReservationStatus.CANCELLED) {
            return true; // Already cancelled
        }
        
        if (reservation.getStatus() == ReservationStatus.COMPLETED) {
            throw new IllegalStateException("Cannot cancel a completed reservation");
        }
        
        // Release seats
        List<Seat> seats = reservation.getSeats();
        if (seats != null) {
            for (Seat seat : seats) {
                seat.setAvailable(true);
                seatDAO.update(seat);
            }
        }
        
        // Release flight seats
        if (reservation.getFlight() != null) {
            flightService.releaseSeats(
                reservation.getFlight().getFlightNumber(),
                seats != null ? seats.size() : 0
            );
        }
        
        // Update reservation status
        reservation.setStatus(ReservationStatus.CANCELLED);
        return reservationDAO.update(reservation);
    }
    
    /**
     * Modify a reservation (change seats).
     * Note: This creates a new reservation since Reservation entity doesn't have setters for seats/totalPrice.
     * @param reservationId Reservation ID to modify
     * @param newSeats New list of seats
     * @return New modified reservation or null if modification failed
     */
    public Reservation modifyReservation(int reservationId, List<Seat> newSeats) throws SQLException {
        Reservation oldReservation = reservationDAO.findById(reservationId);
        if (oldReservation == null) {
            return null;
        }
        
        if (oldReservation.getStatus() != ReservationStatus.PENDING && 
            oldReservation.getStatus() != ReservationStatus.CONFIRMED) {
            throw new IllegalStateException("Cannot modify cancelled or completed reservations");
        }
        
        // Cancel old reservation first
        cancelReservation(reservationId);
        
        // Create new reservation with new seats
        return createReservation(oldReservation.getCustomer(), oldReservation.getFlight(), newSeats);
    }
    
    /**
     * Get all reservations for a customer.
     * @param customer Customer
     * @return List of customer's reservations
     */
    public List<Reservation> getCustomerReservations(Customer customer) throws SQLException {
        if (customer == null) {
            throw new IllegalArgumentException("Customer is required");
        }
        
        return reservationDAO.findByCustomerId(customer.getUserId());
    }
    
    /**
     * Get reservation by ID.
     * @param reservationId Reservation ID
     * @return Reservation or null if not found
     */
    public Reservation getReservationById(int reservationId) throws SQLException {
        return reservationDAO.findById(reservationId);
    }
    
    /**
     * Calculate total price for a reservation.
     * @param flight Flight
     * @param seats Selected seats
     * @return Total price
     */
    private double calculateTotalPrice(Flight flight, List<Seat> seats) {
        if (flight == null || seats == null || seats.isEmpty()) {
            return 0.0;
        }
        
        double basePrice = flight.getPrice();
        double total = 0.0;
        
        for (Seat seat : seats) {
            double seatPrice = basePrice;
            
            // Apply seat class multiplier
            if (seat.getSeatClass() != null) {
                switch (seat.getSeatClass()) {
                    case BUSINESS:
                        seatPrice *= 1.5; // 50% premium
                        break;
                    case FIRST:
                        seatPrice *= 2.5; // 150% premium
                        break;
                    case ECONOMY:
                    default:
                        // Base price
                        break;
                }
            }
            
            total += seatPrice;
        }
        
        return total;
    }
}
