package businesslogic.services;

import businesslogic.entities.Reservation;
import businesslogic.entities.Customer;
import businesslogic.entities.User;
import businesslogic.entities.Flight;
import businesslogic.entities.Seat;
import businesslogic.entities.Payment;
import businesslogic.entities.enums.ReservationStatus;
import businesslogic.entities.enums.MembershipStatus;
import datalayer.dao.ReservationDAO;
import datalayer.dao.SeatDAO;
import datalayer.database.DatabaseConnection;

import java.sql.SQLException;
import java.time.LocalDateTime;
import java.util.List;

/**
 * Service class for reservation-related business logic.
 * Handles creating, modifying, and canceling reservations.
 */
public class ReservationService {
    
    private ReservationDAO reservationDAO;
    private SeatDAO seatDAO;
    private FlightService flightService;
    
    public ReservationService(ReservationDAO reservationDAO,
                              SeatDAO seatDAO,
                              FlightService flightService) {
        this.reservationDAO = reservationDAO;
        this.seatDAO = seatDAO;
        this.flightService = flightService;
    }
    
    /**
     * Create a new reservation.
     * @param customer Customer making the reservation
     * @param flight Flight being reserved
     * @param selectedSeats List of seats to reserve
     * @return Created reservation or null if creation failed
     */
    public Reservation createReservation(Customer customer, Flight flight, 
                                        List<Seat> selectedSeats) throws SQLException {
        if (customer == null || flight == null || selectedSeats == null || selectedSeats.isEmpty()) {
            throw new IllegalArgumentException("Customer, flight, and seats are required");
        }
        
        // Validate seats are available
        for (Seat seat : selectedSeats) {
            Seat dbSeat = seatDAO.findById(seat.getSeatId());
            if (dbSeat == null || !dbSeat.isAvailable()) {
                throw new IllegalStateException("Seat " + seat.getSeatNumber() + " is not available");
            }
        }
        
        // Check flight has enough available seats
        if (flight.getAvailableSeats() < selectedSeats.size()) {
            throw new IllegalStateException("Not enough seats available on flight");
        }
        
        // Calculate total price
        double totalPrice = calculateTotalPrice(flight, selectedSeats);
        
        // Create reservation with PENDING status
        Reservation reservation = new Reservation(
            0, // ID will be generated by database
            LocalDateTime.now(),
            ReservationStatus.PENDING,
            totalPrice,
            customer,
            flight,
            null, // Payment will be added later
            selectedSeats
        );
        
        // Save reservation
        Reservation saved = reservationDAO.save(reservation);
        
        // Mark seats as unavailable
        for (Seat seat : selectedSeats) {
            seat.setAvailable(false);
            seatDAO.update(seat);
        }
        
        // Update flight available seats
        flightService.bookSeats(flight.getFlightNumber(), selectedSeats.size());
        
        return saved;
    }
    
    /**
     * Confirm a reservation (after payment is processed).
     * @param reservationId Reservation ID
     * @param payment Payment object
     * @return true if confirmation successful
     */
    public boolean confirmReservation(int reservationId, Payment payment) throws SQLException {
        Reservation reservation = reservationDAO.findById(reservationId);
        if (reservation == null) {
            return false;
        }
        
        if (reservation.getStatus() != ReservationStatus.PENDING) {
            throw new IllegalStateException("Only pending reservations can be confirmed");
        }
        
        reservation.setStatus(ReservationStatus.CONFIRMED);
        reservation.setPayment(payment);
        
        return reservationDAO.update(reservation);
    }
    
    /**
     * Cancel a reservation.
     * @param reservationId Reservation ID
     * @return true if cancellation successful
     */
    public boolean cancelReservation(int reservationId) throws SQLException {
        Reservation reservation = reservationDAO.findById(reservationId);
        if (reservation == null) {
            return false;
        }
        
        if (reservation.getStatus() == ReservationStatus.CANCELLED) {
            return true; // Already cancelled
        }
        
        if (reservation.getStatus() == ReservationStatus.COMPLETED) {
            throw new IllegalStateException("Cannot cancel a completed reservation");
        }
        
        // Release seats
        List<Seat> seats = reservation.getSeats();
        if (seats != null) {
            for (Seat seat : seats) {
                seat.setAvailable(true);
                seatDAO.update(seat);
            }
        }
        
        // Release flight seats
        if (reservation.getFlight() != null) {
            flightService.releaseSeats(
                reservation.getFlight().getFlightNumber(),
                seats != null ? seats.size() : 0
            );
        }
        
        // Update reservation status
        reservation.setStatus(ReservationStatus.CANCELLED);
        return reservationDAO.update(reservation);
    }
    
    /**
     * Modify a reservation (change seats).
     * Note: This creates a new reservation since Reservation entity doesn't have setters for seats/totalPrice.
     * @param reservationId Reservation ID to modify
     * @param newSeats New list of seats
     * @return New modified reservation or null if modification failed
     */
    public Reservation modifyReservation(int reservationId, List<Seat> newSeats) throws SQLException {
        Reservation oldReservation = reservationDAO.findById(reservationId);
        if (oldReservation == null) {
            return null;
        }
        
        if (oldReservation.getStatus() != ReservationStatus.PENDING && 
            oldReservation.getStatus() != ReservationStatus.CONFIRMED) {
            throw new IllegalStateException("Cannot modify cancelled or completed reservations");
        }
        
        // Cancel old reservation first
        cancelReservation(reservationId);
        
        // Create new reservation with new seats
        return createReservation(oldReservation.getCustomer(), oldReservation.getFlight(), newSeats);
    }
    
    /**
     * Get all reservations for a customer.
     * @param customer Customer
     * @return List of customer's reservations
     */
    public List<Reservation> getCustomerReservations(Customer customer) throws SQLException {
        if (customer == null) {
            throw new IllegalArgumentException("Customer is required");
        }
        
        return reservationDAO.findByCustomerId(customer.getUserId());
    }
    
    /**
     * Get all reservations for any user (customer, admin, or agent).
     * Works by looking up reservations by userId.
     * @param user User (can be Customer, SystemAdmin, or FlightAgent)
     * @return List of user's reservations
     */
    public List<Reservation> getUserReservations(User user) throws SQLException {
        if (user == null) {
            throw new IllegalArgumentException("User is required");
        }
        
        return reservationDAO.findByCustomerId(user.getUserId());
    }
    
    /**
     * Create a reservation for any user (customer, admin, or agent).
     * If user is not a Customer, converts them to a Customer object for the reservation.
     * @param user User making the reservation (can be Customer, SystemAdmin, or FlightAgent)
     * @param flight Flight being reserved
     * @param selectedSeats List of seats to reserve
     * @return Created reservation or null if creation failed
     */
    public Reservation createReservationForUser(User user, Flight flight, 
                                               List<Seat> selectedSeats) throws SQLException {
        if (user == null || flight == null || selectedSeats == null || selectedSeats.isEmpty()) {
            throw new IllegalArgumentException("User, flight, and seats are required");
        }
        
        // Convert User to Customer if needed
        Customer customer;
        if (user instanceof Customer) {
            customer = (Customer) user;
        } else {
            // Create a Customer object from User data for reservation purposes
            customer = new Customer();
            customer.setUserId(user.getUserId());
            customer.setUsername(user.getUsername());
            customer.setPassword(user.getPassword());
            customer.setEmail(user.getEmail());
            customer.setRole(user.getRole());
            // Set default values for customer fields if not available
            customer.setFirstName(user.getUsername()); // Use username as fallback
            customer.setMembershipStatus(MembershipStatus.REGULAR);
        }
        
        return createReservation(customer, flight, selectedSeats);
    }
    
    /**
     * Get reservation by ID.
     * @param reservationId Reservation ID
     * @return Reservation or null if not found
     */
    public Reservation getReservationById(int reservationId) throws SQLException {
        return reservationDAO.findById(reservationId);
    }
    
    /**
     * Get available seats for a flight.
     * Uses SeatDAO to retrieve all seats for the flight and filters by availability.
     * @param flight Flight to get seats for
     * @return List of available seats for the flight
     */
    public List<Seat> getAvailableSeatsForFlight(Flight flight) throws SQLException {
        if (flight == null) {
            throw new IllegalArgumentException("Flight is required");
        }
        
        // Get flight_id from database using flight number
        Integer flightId = getFlightIdByNumber(flight.getFlightNumber());
        if (flightId == null) {
            throw new SQLException("Flight not found: " + flight.getFlightNumber());
        }
        
        // Get available seats using SeatDAO
        return seatDAO.findAvailableSeatsByFlightId(flightId);
    }
    
    /**
     * Get all seats for a flight (available and unavailable).
     * Uses SeatDAO to retrieve all seats for the flight.
     * @param flight Flight to get seats for
     * @return List of all seats for the flight
     */
    public List<Seat> getAllSeatsForFlight(Flight flight) throws SQLException {
        if (flight == null) {
            throw new IllegalArgumentException("Flight is required");
        }
        
        // Get flight_id from database using flight number
        Integer flightId = getFlightIdByNumber(flight.getFlightNumber());
        if (flightId == null) {
            throw new SQLException("Flight not found: " + flight.getFlightNumber());
        }
        
        // Get all seats using SeatDAO
        return seatDAO.findByFlightId(flightId);
    }
    
    /**
     * Get flight_id from database using flight number.
     * @param flightNumber Flight number
     * @return Flight ID or null if not found
     */
    private Integer getFlightIdByNumber(String flightNumber) throws SQLException {
        if (flightNumber == null || flightNumber.isEmpty()) {
            return null;
        }
        
        java.sql.Connection conn = DatabaseConnection.getInstance().getConnection();
        try (java.sql.PreparedStatement stmt = conn.prepareStatement(
                "SELECT flight_id FROM flights WHERE flight_number = ?")) {
            stmt.setString(1, flightNumber);
            try (java.sql.ResultSet rs = stmt.executeQuery()) {
                if (rs.next()) {
                    return rs.getInt("flight_id");
                }
            }
        }
        return null;
    }
    
    /**
     * Calculate total price for a reservation.
     * @param flight Flight
     * @param seats Selected seats
     * @return Total price
     */
    private double calculateTotalPrice(Flight flight, List<Seat> seats) {
        if (flight == null || seats == null || seats.isEmpty()) {
            return 0.0;
        }
        
        double basePrice = flight.getPrice();
        double total = 0.0;
        
        for (Seat seat : seats) {
            double seatPrice = basePrice;
            
            // Apply seat class multiplier
            if (seat.getSeatClass() != null) {
                switch (seat.getSeatClass()) {
                    case BUSINESS:
                        seatPrice *= 1.5; // 50% premium
                        break;
                    case FIRST:
                        seatPrice *= 2.5; // 150% premium
                        break;
                    case ECONOMY:
                    default:
                        // Base price
                        break;
                }
            }
            
            total += seatPrice;
        }
        
        return total;
    }
}
