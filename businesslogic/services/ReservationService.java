package businesslogic.services;

import businesslogic.entities.Reservation;
import businesslogic.entities.Customer;
import businesslogic.entities.User;
import businesslogic.entities.Flight;
import businesslogic.entities.Seat;
import businesslogic.entities.Payment;
import businesslogic.entities.enums.ReservationStatus;
import businesslogic.entities.enums.MembershipStatus;
import datalayer.dao.ReservationDAO;
import datalayer.dao.SeatDAO;
import datalayer.database.DatabaseConnection;

import java.sql.SQLException;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;

/**
 * ReservationService - Handles reservation business logic.
 * Manages booking creation, modification, cancellation, and retrieval.
 *
 * Location: businesslogic/services/ReservationService.java
 */
public class ReservationService {

    private final ReservationDAO reservationDAO;
    private final SeatDAO seatDAO;
    private final FlightService flightService;

    public ReservationService(ReservationDAO reservationDAO,
                              SeatDAO seatDAO,
                              FlightService flightService) {
        this.reservationDAO = reservationDAO;
        this.seatDAO = seatDAO;
        this.flightService = flightService;
    }

    // ---------------------------------------------------------------------
    // Core reservation creation (used by all public create* methods)
    // ---------------------------------------------------------------------
    private Reservation createReservationInternal(Customer customer,
                                                  Flight flight,
                                                  List<Seat> selectedSeats,
                                                  Payment payment) throws SQLException {
        if (customer == null || flight == null || selectedSeats == null || selectedSeats.isEmpty()) {
            throw new IllegalArgumentException("Customer, flight, and seats are required.");
        }

        // Validate seats are still available (from DB)
        for (Seat seat : selectedSeats) {
            Seat dbSeat = seatDAO.findById(seat.getSeatId());
            if (dbSeat == null) {
                throw new IllegalStateException("Seat " + seat.getSeatNumber() + " not found.");
            }
            if (!dbSeat.isAvailable()) {
                throw new IllegalStateException("Seat " + seat.getSeatNumber()
                        + " is no longer available. Please select different seats.");
            }
        }

        // Check flight has enough available seats
        if (flight.getAvailableSeats() < selectedSeats.size()) {
            throw new IllegalStateException("Not enough seats available on flight.");
        }

        // Calculate total price
        double totalPrice = calculateTotalPrice(flight, selectedSeats);

        // Determine initial status (CONFIRMED if payment present, else PENDING)
        ReservationStatus status =
                (payment != null) ? ReservationStatus.CONFIRMED : ReservationStatus.PENDING;

        // Create reservation entity
        Reservation reservation = new Reservation(
                0,                               // ID generated by DB
                LocalDateTime.now(),
                status,
                totalPrice,
                customer,
                flight,
                payment,
                new ArrayList<>(selectedSeats)
        );

        // Save reservation
        Reservation saved = reservationDAO.save(reservation);

        // Mark seats as unavailable
        for (Seat seat : selectedSeats) {
            seat.setAvailable(false);
            seatDAO.update(seat);
        }

        // Update flight available seats via FlightService
        // (wrap in try to avoid failing the whole operation if this part fails)
        try {
            flightService.bookSeats(flight.getFlightNumber(), selectedSeats.size());
        } catch (SQLException e) {
            System.err.println("Warning: Could not update flight available seats: " + e.getMessage());
        }

        return saved;
    }

    // ---------------------------------------------------------------------
    // Creation APIs
    // ---------------------------------------------------------------------

    /**
     * Create a reservation for a customer with optional payment.
     * If payment is non-null the reservation starts as CONFIRMED, else PENDING.
     */
    public Reservation createReservation(Customer customer,
                                         Flight flight,
                                         List<Seat> selectedSeats,
                                         Payment payment) throws SQLException {
        return createReservationInternal(customer, flight, selectedSeats, payment);
    }

    /**
     * Create a reservation for a customer without payment (PENDING).
     * Convenience overload kept from File 2.
     */
    public Reservation createReservation(Customer customer,
                                         Flight flight,
                                         List<Seat> selectedSeats) throws SQLException {
        return createReservationInternal(customer, flight, selectedSeats, null);
    }

    /**
     * Create a reservation for any user type (Customer, FlightAgent, SystemAdmin),
     * with optional payment.
     */
    public Reservation createReservationForUser(User user,
                                                Flight flight,
                                                List<Seat> selectedSeats,
                                                Payment payment) throws SQLException {
        if (user == null || flight == null || selectedSeats == null || selectedSeats.isEmpty()) {
            throw new IllegalArgumentException("User, flight, and seats are required.");
        }

        // Convert User to Customer if needed (uses richer conversion from File 2)
        Customer customer;
        if (user instanceof Customer) {
            customer = (Customer) user;
        } else {
            customer = new Customer();
            customer.setUserId(user.getUserId());
            customer.setUsername(user.getUsername());
            customer.setPassword(user.getPassword());
            customer.setEmail(user.getEmail());
            customer.setRole(user.getRole());
            // Sensible defaults
            customer.setFirstName(user.getUsername());
            customer.setMembershipStatus(MembershipStatus.REGULAR);
        }

        return createReservationInternal(customer, flight, selectedSeats, payment);
    }

    /**
     * Create a reservation for any user (Customer, admin, agent) without payment (PENDING).
     * Overload preserved from File 2.
     */
    public Reservation createReservationForUser(User user,
                                                Flight flight,
                                                List<Seat> selectedSeats) throws SQLException {
        return createReservationForUser(user, flight, selectedSeats, null);
    }

    // ---------------------------------------------------------------------
    // Confirm / cancel / modify
    // ---------------------------------------------------------------------

    /**
     * Confirm a reservation (after payment is processed).
     * Returns true if confirmation succeeded.
     * Signature and return type kept from File 2.
     */
    public boolean confirmReservation(int reservationId, Payment payment) throws SQLException {
        Reservation reservation = reservationDAO.findById(reservationId);
        if (reservation == null) {
            return false;
        }

        if (reservation.getStatus() != ReservationStatus.PENDING) {
            throw new IllegalStateException("Only pending reservations can be confirmed.");
        }

        reservation.setStatus(ReservationStatus.CONFIRMED);
        reservation.setPayment(payment);

        return reservationDAO.update(reservation);
    }

    /**
     * Cancel a reservation.
     * Returns:
     *  - false if reservation does not exist,
     *  - true if already cancelled or successfully cancelled,
     *  - throws if reservation is COMPLETED.
     *
     * Combines File 2 behavior with File 1's logging style.
     */
    public boolean cancelReservation(int reservationId) throws SQLException {
        Reservation reservation = reservationDAO.findById(reservationId);
        if (reservation == null) {
            return false;
        }

        if (reservation.getStatus() == ReservationStatus.CANCELLED) {
            return true; // Already cancelled
        }

        if (reservation.getStatus() == ReservationStatus.COMPLETED) {
            throw new IllegalStateException("Cannot cancel a completed reservation.");
        }

        // Release seats
        List<Seat> seats = reservation.getSeats();
        if (seats != null) {
            for (Seat seat : seats) {
                seat.setAvailable(true);
                seatDAO.update(seat);
            }
        }

        // Release flight seats via FlightService
        if (reservation.getFlight() != null && seats != null) {
            try {
                flightService.releaseSeats(
                        reservation.getFlight().getFlightNumber(),
                        seats.size()
                );
            } catch (SQLException e) {
                System.err.println("Warning: Could not update flight available seats: " + e.getMessage());
            }
        }

        // Update reservation status
        reservation.setStatus(ReservationStatus.CANCELLED);
        return reservationDAO.update(reservation);
    }

    /**
     * Modify a reservation (change seats).
     * Creates a new reservation with new seats after cancelling the old one.
     * From File 2.
     */
    public Reservation modifyReservation(int reservationId, List<Seat> newSeats) throws SQLException {
        Reservation oldReservation = reservationDAO.findById(reservationId);
        if (oldReservation == null) {
            return null;
        }

        if (oldReservation.getStatus() != ReservationStatus.PENDING &&
            oldReservation.getStatus() != ReservationStatus.CONFIRMED) {
            throw new IllegalStateException("Cannot modify cancelled or completed reservations.");
        }

        // Cancel old reservation first
        cancelReservation(reservationId);

        // Create new reservation with new seats, no payment by default (still PENDING)
        return createReservation(oldReservation.getCustomer(), oldReservation.getFlight(), newSeats);
    }

    // ---------------------------------------------------------------------
    // Retrieval APIs
    // ---------------------------------------------------------------------

    /**
     * Get all reservations for a customer.
     */
    public List<Reservation> getCustomerReservations(Customer customer) throws SQLException {
        if (customer == null) {
            throw new IllegalArgumentException("Customer is required.");
        }
        return reservationDAO.findByCustomerId(customer.getUserId());
    }

    /**
     * Get all reservations for any user (Customer, SystemAdmin, FlightAgent).
     */
    public List<Reservation> getUserReservations(User user) throws SQLException {
        if (user == null) {
            throw new IllegalArgumentException("User is required.");
        }
        return reservationDAO.findByCustomerId(user.getUserId());
    }

    /**
     * Get reservation by ID.
     */
    public Reservation getReservationById(int reservationId) throws SQLException {
        return reservationDAO.findById(reservationId);
    }

    /**
     * Get all reservations for a specific flight.
     * (From File 1.)
     */
    public List<Reservation> getReservationsByFlight(int flightId) throws SQLException {
        return reservationDAO.findByFlightId(flightId);
    }

    /**
     * Get all reservations (admin/agent use).
     * (From File 1.)
     */
    public List<Reservation> getAllReservations() throws SQLException {
        return reservationDAO.findAll();
    }

    // ---------------------------------------------------------------------
    // Seat lookup for a flight
    // ---------------------------------------------------------------------

    /**
     * Get available seats for a flight.
     * Uses SeatDAO to retrieve all seats for the flight and filters by availability.
     */
    public List<Seat> getAvailableSeatsForFlight(Flight flight) throws SQLException {
        if (flight == null) {
            throw new IllegalArgumentException("Flight is required.");
        }

        Integer flightId = getFlightIdByNumber(flight.getFlightNumber());
        if (flightId == null) {
            throw new SQLException("Flight not found: " + flight.getFlightNumber());
        }

        return seatDAO.findAvailableSeatsByFlightId(flightId);
    }

    /**
     * Get all seats for a flight (available and unavailable).
     * Uses SeatDAO to retrieve all seats for the flight.
     */
    public List<Seat> getAllSeatsForFlight(Flight flight) throws SQLException {
        if (flight == null) {
            throw new IllegalArgumentException("Flight is required.");
        }

        Integer flightId = getFlightIdByNumber(flight.getFlightNumber());
        if (flightId == null) {
            throw new SQLException("Flight not found: " + flight.getFlightNumber());
        }

        return seatDAO.findByFlightId(flightId);
    }

    // ---------------------------------------------------------------------
    // Helpers
    // ---------------------------------------------------------------------

    /**
     * Get flight_id from database using flight number.
     */
    private Integer getFlightIdByNumber(String flightNumber) throws SQLException {
        if (flightNumber == null || flightNumber.isEmpty()) {
            return null;
        }

        java.sql.Connection conn = DatabaseConnection.getInstance().getConnection();
        try (java.sql.PreparedStatement stmt = conn.prepareStatement(
                "SELECT flight_id FROM flights WHERE flight_number = ?")) {
            stmt.setString(1, flightNumber);
            try (java.sql.ResultSet rs = stmt.executeQuery()) {
                if (rs.next()) {
                    return rs.getInt("flight_id");
                }
            }
        }
        return null;
    }

    /**
     * Calculate total price for a booking.
     * Kept public (File 1) so other layers can reuse it if needed.
     */
    public double calculateTotalPrice(Flight flight, List<Seat> seats) {
        if (flight == null || seats == null || seats.isEmpty()) {
            return 0.0;
        }

        double basePrice = flight.getPrice();
        double total = 0.0;

        for (Seat seat : seats) {
            double seatPrice = basePrice;

            if (seat.getSeatClass() != null) {
                switch (seat.getSeatClass()) {
                    case BUSINESS:
                        seatPrice *= 1.5; // 50% premium
                        break;
                    case FIRST:
                        seatPrice *= 2.5; // 150% premium
                        break;
                    case ECONOMY:
                    default:
                        // Base price
                        break;
                }
            }

            total += seatPrice;
        }

        return total;
    }
}
