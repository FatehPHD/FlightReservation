package businesslogic.services;

import businesslogic.entities.Payment;
import businesslogic.entities.enums.PaymentMethod;
import businesslogic.entities.enums.PaymentStatus;
import datalayer.dao.PaymentDAO;

import java.sql.SQLException;
import java.time.LocalDateTime;
import java.util.UUID;

/**
 * Service class for payment-related business logic.
 * Handles simulated payment processing (no real payment gateway).
 */
public class PaymentService {
    
    private PaymentDAO paymentDAO;
    
    public PaymentService(PaymentDAO paymentDAO) {
        this.paymentDAO = paymentDAO;
    }
    
    /**
     * Process a payment (simulated).
     * @param amount Payment amount
     * @param paymentMethod Payment method
     * @return Payment object with status
     */
    public Payment processPayment(double amount, PaymentMethod paymentMethod) throws SQLException {
        if (amount <= 0) {
            throw new IllegalArgumentException("Payment amount must be positive");
        }
        
        if (paymentMethod == null) {
            throw new IllegalArgumentException("Payment method is required");
        }
        
        // Simulate payment processing
        // In a real system, this would call a payment gateway
        String transactionId = generateTransactionId();
        PaymentStatus status = simulatePaymentProcessing(amount, paymentMethod);
        
        Payment payment = new Payment(
            0, // ID will be generated by database
            amount,
            LocalDateTime.now(),
            paymentMethod,
            transactionId,
            status
        );
        
        return paymentDAO.save(payment);
    }
    
    /**
     * Process a payment and return the result immediately (simulated).
     * For this project, payments are always successful (simulated).
     * @param amount Payment amount
     * @param paymentMethod Payment method
     * @return Payment object with COMPLETED status
     */
    public Payment processPaymentSimulated(double amount, PaymentMethod paymentMethod) throws SQLException {
        if (amount <= 0) {
            throw new IllegalArgumentException("Payment amount must be positive");
        }
        
        if (paymentMethod == null) {
            throw new IllegalArgumentException("Payment method is required");
        }
        
        String transactionId = generateTransactionId();
        
        Payment payment = new Payment(
            0, // ID will be generated by database
            amount,
            LocalDateTime.now(),
            paymentMethod,
            transactionId,
            PaymentStatus.COMPLETED // Simulated - always successful
        );
        
        return paymentDAO.save(payment);
    }
    
    /**
     * Get payment by ID.
     * @param paymentId Payment ID
     * @return Payment or null if not found
     */
    public Payment getPaymentById(int paymentId) throws SQLException {
        return paymentDAO.findById(paymentId);
    }
    
    /**
     * Update payment status (e.g., for refunds).
     * @param paymentId Payment ID
     * @param newStatus New payment status
     * @return true if update successful
     */
    public boolean updatePaymentStatus(int paymentId, PaymentStatus newStatus) throws SQLException {
        Payment payment = paymentDAO.findById(paymentId);
        if (payment == null) {
            return false;
        }
        
        payment.setStatus(newStatus);
        return paymentDAO.update(payment);
    }
    
    /**
     * Process a refund for a payment.
     * @param paymentId Payment ID to refund
     * @return true if refund successful
     */
    public boolean processRefund(int paymentId) throws SQLException {
        Payment payment = paymentDAO.findById(paymentId);
        if (payment == null) {
            return false;
        }
        
        if (payment.getStatus() != PaymentStatus.COMPLETED) {
            throw new IllegalStateException("Only completed payments can be refunded");
        }
        
        payment.setStatus(PaymentStatus.REFUNDED);
        return paymentDAO.update(payment);
    }
    
    /**
     * Generate a unique transaction ID (simulated).
     * @return Transaction ID string
     */
    private String generateTransactionId() {
        return "TXN-" + UUID.randomUUID().toString().substring(0, 8).toUpperCase() + 
               "-" + System.currentTimeMillis();
    }
    
    /**
     * Simulate payment processing (for demonstration).
     * In this project, payments are always successful.
     * @param amount Payment amount
     * @param method Payment method
     * @return PaymentStatus (simulated as COMPLETED)
     */
    private PaymentStatus simulatePaymentProcessing(double amount, PaymentMethod method) {
        // Simulated payment processing
        // In a real system, this would:
        // 1. Validate payment details
        // 2. Contact payment gateway
        // 3. Process transaction
        // 4. Return actual status
        
        // For this project, always return COMPLETED
        return PaymentStatus.COMPLETED;
    }
}
